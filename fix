#include <iostream>
#include <string>
#include <cstdint>
#include <math.h>
#include <bitset>
#include <limits>
#include <vector>
#include <iostream>
#include <fstream>
#include <sstream>

using namespace std;

long long MAX = 1000, MAX1 = 10000;

int parseHex(char o) {
    if ('0' <= o && o <= '9') {
        return o - '0';
    }
    if ('A' <= o && o <= 'Z') {
        return o - 'A' + 10;
    }
    if ('a' <= o && o <= 'z') {
        return o - 'a' + 10;
    }
}

void ParseNumber(string s, uint64_t &num) {
    for (int i = 2; i < s.size(); i++) {
        num = num * 16 + parseHex(s[i]);
    }
}

uint64_t conve(uint64_t a, int AB) {
    bitset<64> b(a);
    bool f = 0;
    for (int i = 0; i < AB; i++) {
        if (f) {
            b[i] = !b[i];
        }
        if (b[i] == 1) {
            f = 1;
        }
    }
    cout << b << "     bitset\n";
    return (uint64_t) (b.to_ulong());
}

bool checks(uint64_t n, int AB) {
    bitset<64> b(n);
    return b[AB];
}

uint64_t rounds(uint64_t n, int sign, bool f, uint64_t r, int B) {
    if (sign == 0) {
        return n;
    } else if (sign == 1) {
        if (r > (1 << B)) {
            return n + 1;
        } else if (r == (1 << B)) {
            if (n % 10 % 2) {
                return n + 1;
            }
        }
    } else if (sign == 2) {
        if (!f && r) {
            return n + 1;
        }
    } else {
        if (f && r) return n + 1;
    }
    return n;
}

void print(uint64_t n, bool f) {
    string s = to_string(n);
    if (!n) {
        cout << "0.000\n";
        return;
    }
    if (f) cout << '-';
    if (s.size() <= 3) {
        cout << "0.";
        for (int i = 0; i < 3 - s.size(); i++) {
            cout << '0';
        }
        cout << s << "\n";
        return;
    }
    string a = s.substr(0, s.size() - 3);
    cout << a << '.' << s.substr(s.size() - 3, 3) << "\n";
}

bool checkdeb(uint64_t n, int AB) {
    return n / (1 << AB);
}

int tr() {
    ofstream out; // поток для записи
    out.open("anshjk.txt");
    ifstream in("test.txt");
    for (int i = 0; i < 12; i++) {
        string s;
        getline(in, s);
        //cout << s << "\n";
        vector<string> argv;
        istringstream iss(s);
        string w;
        while (iss >> w) {
            argv.push_back(w);
        }
        //cout << argv[0] << "\n";
        int argc = stoi(argv[0]);
        if (argc == 4) {
            string fd = argv[2], sd = argv[3], td = argv[4];
            int A = stoi(fd.substr(0, fd.find('.'))), B = stoi(fd.substr(fd.find('.') + 1, fd.size()));
            uint64_t num = 0;
            for (int i = 2; i < td.size(); i++) {
                num = num * 16 + parseHex(td[i]);
            }
            bitset<64> bit1(num);
            num <<= (64 - A - B);
            num >>= (64 - A - B);
            bitset<64> bit2(num);
            //cout << num << "    num\n";
            //cout << bit1 << "    firstbit\n" << bit2 << "    secondbit\n";
            bool f = checks(num, A + B - 1);
            if (f) num = conve(num, A + B);
            uint64_t rem = num * MAX % (1 << B);
            num = num * MAX;
            num >>= B;
            if (rem < 0) rem = -rem;
            num = rounds(num, stoi(sd), f, rem, B - 1);
            //print(num, f);
            if (!num) {
                out << "0.000\n";
                continue;
            }
            //cout << n << "     ___n\n";
            s = to_string(num);
            if (!num) {
                out << "0.000\n";
                continue;
            }
            if (f) out << '-';
            if (s.size() <= 3) {
                out << "0.";
                for (int i = 0; i < 3 - s.size(); i++) {
                    out << '0';
                }
                out << s << "\n";
                continue;
            }
            string a = s.substr(0, s.size() - 3);
            out << a << '.' << s.substr(s.size() - 3, 3) << "\n";
        } else if (argc == 6) {
            string fd = argv[2], fod = argv[5], fivd = argv[6], secd = argv[4], trd = argv[3];
            int A = stoi(fd.substr(0, fd.find('.'))), B = stoi(fd.substr(fd.find('.') + 1, fd.size()));
            uint64_t num1 = 0, num2 = 0;
            for (int i = 2; i < fod.size(); i++) {
                num1 = num1 * 16 + parseHex(fod[i]);
            }
            for (int i = 2; i < fivd.size(); i++) {
                num2 = num2 * 16 + parseHex(fivd[i]);
            }
            if (secd == "/" && checkdeb(num2, A + B)) {
                cout << "div_by_zero";
                continue;
            }
            if (secd == "+" || secd == "-") {
                uint64_t num = 0;
                if (secd == "+") { num = num1 + num2; } else { num = num1 - num2; }
                num <<= (64 - A - B);
                num >>= (64 - A - B);
                bool f = checks(num, A + B - 1);
                if (f) num = conve(num, A + B);
                int rem = num * MAX % (1 << B);
                num = num * MAX;
                num >>= B;
                num = rounds(num, stoi(trd), f, rem, B - 1);
                if (!num) {
                    out << "0.000\n";
                    continue;
                }
                //cout << n << "     ___n\n";
                s = to_string(num);
                if (!num) {
                    out << "0.000\n";
                    continue;
                }
                if (f) out << '-';
                if (s.size() <= 3) {
                    out << "0.";
                    for (int i = 0; i < 3 - s.size(); i++) {
                        out << '0';
                    }
                    out << s << "\n";
                    continue;
                }
                string a = s.substr(0, s.size() - 3);
                out << a << '.' << s.substr(s.size() - 3, 3) << "\n";
            } else {
                if (secd == "!") {
                    bool f1 = checks(num1, A + B - 1), f2 = checks(num2, A + B - 1), f = (f1 + f2) % 2;;
                    if (f1) num1 = conve(num1, A + B);
                    if (f2) num2 = conve(num2, A + B);
                    uint64_t num = num1 * num2;
                    num <<= (64 - A - 2 * B);
                    num >>= (64 - A - B);
                    if (f) num = conve(num, A + B);
                    uint64_t rem = num * MAX % (1 << B);
                    num = num * MAX;
                    num >>= B;
                    bool f3 = checks(num, A + B - 1);
                    //if (rem < 0) rem = -rem;
                    num = rounds(num, stoi(trd), f, rem, B - 1);
                    s = to_string(num);
                    if (!num) {
                        out << "0.000\n";
                        continue;
                    }
                    if (f) out << '-';
                    if (s.size() <= 3) {
                        out << "0.";
                        for (int i = 0; i < 3 - s.size(); i++) {
                            out << '0';
                        }
                        out << s << "\n";
                        continue;
                    }
                    string a = s.substr(0, s.size() - 3);
                    out << a << '.' << s.substr(s.size() - 3, 3) << "\n";
                }
                /*bool f1 = checks(num1, A + B - 1), f2 = checks(num2, A + B - 1);
                if (f1) num1 = conve(num1, A + B);
                if (f2) num2 = conve(num2, A + B);
                num1 = num1 * MAX / (1 << B);
                num2 = num2 * MAX / (1 << B);
                cout << num1 << "     " << num2 << "\n";
                pair<bool, uint64_t> m = comp(num1, num2, f1, f2, secd, B);
                cout << "lkjhgfdsdfghjk\n";
                m.second = rounds(m.second, stoi(trd), m.first);
                print(m.second, m.first);*/
            }
        }
    }
}

int main(int argc, char *argv[]) {
    if (argc == 4) {
        string AB = argv[1], roundnum = argv[2], strnum = argv[3];
        int A = stoi(AB.substr(0, AB.find('.'))), B = stoi(AB.substr(AB.find('.') + 1, AB.size()));
        uint64_t num = 0;
        ParseNumber(strnum, num);
        num <<= (64 - A - B);
        num >>= (64 - A - B);
        bool f = checks(num, A + B - 1);
        if (f) num = conve(num, A + B);
        uint64_t rem = num * MAX % (1 << B);
        num = num * MAX;
        num >>= B;
        //if (rem < 0) rem = -rem;
        num = rounds(num, stoi(roundnum), f, rem, B - 1);
        print(num, f);
        cout << rem << "   rem   " << (1 << (B - 1));
    } else if (argc == 6) {
        string AB = argv[1], sign = argv[3], firstnum = argv[4], secondnum = argv[5], roundnum = argv[2];
        int A = stoi(AB.substr(0, AB.find('.'))), B = stoi(AB.substr(AB.find('.') + 1, AB.size()));
        uint64_t num1 = 0, num2 = 0;
        ParseNumber(firstnum, num1);
        ParseNumber(secondnum, num2);
        num1 <<= (64 - A - B);
        num1 >>= (64 - A - B);
        num2 <<= (64 - A - B);
        num2 >>= (64 - A - B); // это возможно не нужно
        if (sign == "/" && checkdeb(num2, A + B)) {
            cout << "div_by_zero";
            return 0;
        }
        if (sign == "+" || sign == "-") {
            uint64_t num = 0;
            if (sign == "+") { num = num1 + num2; } else { num = num1 - num2; }
            num <<= (64 - A - B);
            num >>= (64 - A - B);
            bool f = checks(num, A + B - 1);
            if (f) num = conve(num, A + B);
            uint64_t rem = num * MAX % (1 << B);
            num = num * MAX;
            num >>= B;
            //if (rem < 0) rem = -rem;
            num = rounds(num, stoi(roundnum), f, rem, B - 1);
            print(num, f);
            cout << rem << "   rem\n";
        } else {
            if (sign == "!") {
                bool f1 = checks(num1, A + B - 1), f2 = checks(num2, A + B - 1), f = (f1 + f2) % 2;;
                if (f1) num1 = conve(num1, A + B);
                if (f2) num2 = conve(num2, A + B);
                uint64_t num = num1 * num2;
                num <<= (64 - A - 2 * B);
                num >>= (64 - A - B);
                if (f) num = conve(num, A + B);
                uint64_t rem = num * MAX % (1 << B);
                num = num * MAX;
                num >>= B;
                bool f3 = checks(num, A + B - 1);
                //if (rem < 0) rem = -rem;
                num = rounds(num, stoi(roundnum), f, rem, B - 1);
                cout << f << "   "<< f3 << "     pos or neg\n";
                print(num, f3);
            } else {
                bool f1 = checks(num1, A + B - 1), f2 = checks(num2, A + B - 1), f = (f1 + f2) % 2;//f = f1*f2;//f = (f1 + f2) % 2;;
                num1 <<= B;
                uint64_t num = num1 / num2;
                num <<= (64 - A - 2 * B);
                num >>= (64 - A - B);
                //if (f) num = conve(num, A + B);
                uint64_t rem = num * MAX % (1 << B);
                num = num * MAX;
                num >>= B;
                bool f3 = checks(num, A + B - 1);
                //if (rem < 0) rem = -rem;
                num = rounds(num, stoi(roundnum), f, rem, B - 1);
                cout << f << "   "<< f3 << "     pos or neg\n";
                print(num, f3);
            }
        }
    }
}

// 01101100111100110
// remains не надо abs, возможно не надо uint64_t

        /*bitset<64> b(num);
        cout << b << "\n";
        rem >>= 10;
        bitset<64> b2(rem);
        cout << b2 << "\n"; // это типо пиздатый сдвиг remains для 1.31*/
