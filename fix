#include <iostream>
#include <string>
#include <cstdint>
#include <math.h>
#include <bitset>
#include <limits>
#include <vector>
#include <iostream>
#include <fstream>
#include <sstream>

using namespace std;

uint64_t MAX = 1000, MAX1 = 10000;

int parseHex(char o) {
    if ('0' <= o && o <= '9') {
        return o - '0';
    }
    if ('A' <= o && o <= 'Z') {
        return o - 'A' + 10;
    }
    if ('a' <= o && o <= 'z') {
        return o - 'a' + 10;
    }
    return 0;
}

void ParseNumber(string s, uint64_t &num, int A, int B) {
    num = 0;
    for (int i = 2; i < s.size(); i++) {
        num = num * 16 + parseHex(s[i]);
    }
    num &= ((1ULL << (A + B)) - 1);
}

void conve(uint64_t &a, int AB) {
    bitset<64> b(a);
    bool f = 0;
    for (int i = 0; i < AB; i++) {
        if (f) {
            b[i] = !b[i];
        }
        if (b[i] == 1) {
            f = 1;
        }
    }
    a = (uint64_t) (b.to_ullong());
}

bool checks(uint64_t n, int AB) {
    bitset<64> b(n);
    return b[AB];
}

uint64_t rounds(uint64_t n, int sign, bool f, int B) {
    uint64_t r = n * MAX % (1ULL << B);
    n = n * MAX / (1ULL << B);
    if (sign == 0) {
        return n;
    } else if (sign == 1) {
        if (r > (1ULL << (B - 1))) {
            return n + 1;
        } else if (r == (1ULL << (B - 1))) {
            if (n & 1) {
                return n + 1;
            }
        }
    } else if (sign == 2) {
        if (!f && r) {
            return n + 1;
        }
    } else {
        if (f && r) return n + 1;
    }
    return n;
}

uint64_t rounds1(uint64_t n, int sign, bool f, int B) {
    uint64_t r = n % (1ULL << B);
    n >>= B;
    if (sign == 0) {
        return n;
    } else if (sign == 1) {
        if (r > (1ULL << (B - 1))) {
            return n + 1;
        } else if (r == (1ULL << (B - 1))) {
            if (n & 1) {
                return n + 1;
            }
        }
    } else if (sign == 2) {
        if (!f && r) {
            return n + 1;
        }
    } else {
        if (f && r) return n + 1;
    }
    return n;
}

void round_div(uint64_t &num, uint64_t r, uint64_t num2, int sign, bool f) {
    if (!sign) return;
    else if (sign == 1) {
        uint64_t t = r << 1;
        if (t > num2) {
            num++;
            return;
        }
        if (t == num2 && (num && 1ULL)) {
            num++;
            return;
        }
    } else if (sign == 2) {
        if (!f && r) {
            num++;
            return;
        }
        return;
    }
    if (f && r) {
        num++;
        return;
    }
    return;
}

void print(uint64_t n, bool f) {
    string s = to_string(n);
    if (!n) {
        cout << "0.000\n";
        return;
    }
    if (f) cout << '-';
    if (s.size() <= 3) {
        cout << "0.";
        for (int i = 0; i < 3 - s.size(); i++) {
            cout << '0';
        }
        cout << s << "\n";
        return;
    }
    string a = s.substr(0, s.size() - 3);
    cout << a << '.' << s.substr(s.size() - 3, 3) << "\n";
}

void bits(uint64_t n, string s) {
    bitset<64> b(n);
    cout << b << "   " << s << "\n";
}

void addsub(uint64_t &num1, uint64_t &num2, int A, int B, string roundnum, string sign) {
    uint64_t num = 0;
    if (sign == "+") { num = num1 + num2; } else { num = num1 - num2; }

    num &= ((1ULL << (A + B)) - 1);

    bool f = checks(num, A + B - 1);
    if (f) conve(num, A + B);

    num = rounds(num, stoi(roundnum), f, B);
    print(num, f);
}

void mult(uint64_t &num1, uint64_t &num2, int A, int B, string roundnum) {
    // check на минус
    bool f1 = checks(num1, A + B - 1), f2 = checks(num2, A + B - 1);
    if (f1) conve(num1, A + B);
    if (f2) conve(num2, A + B);

    // перемножение
    uint64_t num = num1 * num2;

    // проверка на минус
    bool f3 = (num >> (2 * B + 2 * A - 1)) % 2;

    // округление и вывод
    num = rounds1(num, stoi(roundnum), f1 ^ f2, B);

    //убрали ненужную левую A
    num <<= (64 - A - B);
    num >>= (64 - A - B);

    // проверка на минус
    bool f = checks(num, A + B - 1);
    if (f) conve(num, A + B);
    num = rounds(num, stoi(roundnum), f, B);
    f = f1 ^ f2 ^ f;
    print(num, f);
}

void division(uint64_t &num1, uint64_t &num2, int A, int B, string roundnum) {
    // деление на 0
    if (!(num2)) {
        cout << "div_by_zero";
        return;
    }

    // check на минус
    bool f1 = checks(num1, A + B - 1), f2 = checks(num2, A + B - 1), f3 = f1 ^ f2;
    if (f1) conve(num1, A + B);
    if (f2) conve(num2, A + B);


    num1 <<= B;
    uint64_t num = (uint64_t) (num1 / num2);
    uint64_t r = (uint64_t) (num1 % num2);

    round_div(num, r, num2, stoi(roundnum), f3);

    num <<= (64 - A - B);
    num >>= (64 - A - B);

    bool f = checks(num, A + B - 1);
    if (f) conve(num, A + B);

    f3 = f3 ^ f;

    num = rounds(num, stoi(roundnum), f3, B);
    print(num, f3);
}

int main(int argc, char *argv[]) {
    if (argc == 4) {
        // парсинг элементов командной строки
        string AB = argv[1], roundnum = argv[2], strnum = argv[3];
        int A = stoi(AB.substr(0, AB.find('.'))), B = stoi(AB.substr(AB.find('.') + 1, AB.size()));

        // num в 10-ричную сс
        uint64_t num = 0;
        ParseNumber(strnum, num, A, B);

        // положительный или отрицательный
        bool f = checks(num, A + B - 1);
        if (f) conve(num, A + B);

        //округление и вывод
        num = rounds(num, stoi(roundnum), f, B);
        print(num, f);
    } else if (argc == 6) {
        // парсинг элементов командной строки
        string AB = argv[1], sign = argv[3], firstnum = argv[4], secondnum = argv[5], roundnum = argv[2];
        int A = stoi(AB.substr(0, AB.find('.'))), B = stoi(AB.substr(AB.find('.') + 1, AB.size()));

        // num в 10-ричную сс
        uint64_t num1 = 0, num2 = 0;
        ParseNumber(firstnum, num1, A, B);
        ParseNumber(secondnum, num2, A, B);

        if (sign == "+" || sign == "-") {
            addsub(num1, num2, A, B, roundnum, sign);
        }

        if (sign == "*") {
            mult(num1, num2, A, B, roundnum);
        }

        if (sign == "/") {
            division(num1, num2, A, B, roundnum);
        }
    }
}
